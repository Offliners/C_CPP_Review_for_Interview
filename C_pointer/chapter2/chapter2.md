# Chatper 2 - C語言的動態記憶體管理
## 動態記憶體配置
C語言中動態記憶體配置的基本程序如下:
1. 使用malloc等函數配置記憶體
2. 依應用程式需要使用所配置的記憶體
3. 使用free函數釋放記憶體

```c
int *pi = (int*) malloc(sizeof(int));
*pi = 5;
printf("*pi: %d\n", *pi);
free(pi);
```

![Figure 2-1](./Fig/Figure2-1.png)

malloc函數只有一個指定需要配置記憶體數量的參數，配置成功會回傳在堆積中配置的記憶體位址，失敗則傳回NULL指標。sizeof運算子能提高程式可攜性，正確計算出需要配置的位元組數量。

以下試著配置足夠存放一個整數的記憶體，假設整數大小為4:
```c
int *pi = (int*) malloc(4);
```

由於整數的大小依據使用的記憶體模型而異，教友可攜性的做法是使用sizeof運算子，在任何環境都會傳回正確的大小。

※ 以下是解參考運算子常見的使用錯誤:
```c
int *pi;
*pi = (int*) malloc(sizeof(int));
```
問題出在指派運算子的左側解參考了指標，這會將malloc傳回的位址指派給pi參照的記憶體，如果這是指標的第一次指派，那指標所參照到的記憶體可能不是合法記憶體，正確的用法是:
```c
pi = (int*) malloc(sizeof(int));
```
這種情況並不需要使用解參考運算子。

※ 每個malloc函數 (或其他類似函數)呼叫不再需要配置的記憶體時，就要有對應的free函數呼叫，釋放配置的記憶體以避免記憶體洩漏。

### 記憶體洩漏
記憶體洩漏發生於配置的記憶體已不再使用卻也沒釋放的情況，可能原因為:
1. 遺失記憶體位址
2. 應該呼叫卻沒有呼叫free函數 (這有時稱為隱藏的洩漏)

記憶體洩漏的問題在於無法回收記憶體供後續使用，以下程式碼chunk變數被指派了配置在堆積的記憶體，然而在配置下一塊記憶體前並沒有釋放記憶體，最後應用程式會因為用完記憶體而不正常終止
```c
char *chunk;
while (1) {
    chunk = (char*) malloc(1000000);
    printf("Allocating\n");
}
```

### 遺失記憶體位址
下列程式碼，當pi再次被指派新的位址時會遺失記憶體位址，當第二次pi指派了位址時，就遺失了第一次配置的位址:
```c
int *pi = (int*) malloc(sizeof(int));
*pi = 5;
...
pi = (int*) malloc(sizeof(int));
```

位址500的記憶體沒有被釋放，而程式也不再持有這個位址的參考。
![Figure 2-3](./Fig/Figure2-3.png)

接下來的例子為字串配置了記憶體並初始化，再逐一字元顯示:
```c
char *name = (char*)malloc(strlen("Susan")+1);
strcpy(name,"Susan");
while(*name != 0) {
    printf("%c",*name);
    name++;
}
```

雖然在迴圈中逐次增加了name的值，最後name還是指向字串的NULL終止字元，但遺失了配置給字串使用的起始位址。

![Figure 2-4](./Fig/Figure2-4.png)

### 動態記憶體配置函數